#!/usr/bin/perl
our $APP     = 'rmcd';
our $VERSION = 0.2;
my  $DEBUG = 0;
# rmcd
# Copyright (C) 2010 Magnus Woldrich <trapd00r@trapd00r.se>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
########################################################################

use strict;
use Carp;
use Data::Dumper;
use Getopt::Long;
use Cwd qw(abs_path getcwd);
use File::Copy;
use Mplayer::NowPlaying qw($np_log np stream_np);
use RMCD::Radio qw(geturi listchans getchans);

# imported from config file, if any
our ($dir_to_copy_to,%personal_stations) = (undef);

my $config         = "$ENV{XDG_CONFIG_HOME}/rmcd/rmcd.conf";
my $log            = "$ENV{HOME}/.mplayer/rmcd.log";
my $fifo           = "$ENV{HOME}/.mplayer/rmcd.fifo";
my $pidfile        = '/tmp/mplayerd.pid';
my $player         = 'mplayer';
my @playopt        = ('-cache', 200, '-quiet', '-identify',
                      '-idle', '-input', "file=$fifo"
                    );
$np_log = $log;

# fixe FIXME only rel namn shinfo :)
my $channels = getchans();

# Check if files ^ exist
fileexist();

my %allowed_cmds = (
  next    => 'pt_step 1',
  prev    => 'pt_step -1',
  toggle  => 'pause',
  pause   => 'pause',
  stop    => 'stop',
  fs      => 'fullscreen',
);

our($opt_info_style,@opt_play_songs) = (undef);
GetOptions(
  'kill'       => \&killkid,
  'load:s{1,}' => \@opt_play_songs,
  'cmd:s{,}'   => \&cmd,
  'help'       => \&usage,
  'chanlist'   => \&list_radio,
  'info'       => \&info,
  'si|shinfo'  => sub {$opt_info_style = 1; info()},
  'cp|copy'    => \&cp,
  'fav'        => \&fav,
  'next'       => sub {cmd('FIXME','next')},
  'prev'       => sub {cmd('FIXME','prev')},
  'toggle'     => sub {cmd('FIXME','pause')},
  'fullscreen' => sub {cmd('FIXME','fs')},
  'stop'       => sub {cmd('FIXME','stop')},
  'clist'      => sub {
    print "$_\n" for(keys(%allowed_cmds));
    print "\033[1mSee 'mplayer -input cmdlist'\033[0m\n";
    exit(0);
  },
);

if(@opt_play_songs) {
#  my @fixme = @opt_play_songs;
#  for(@fixme) {
#    s;.+/(.+);$1;;
#    print "Adding \033[1m$1\033[0m\n";
#  }
  load(@opt_play_songs);
}

#my @files = @ARGV; # No opts specified, go on...
#print @files;

#load(@files);

if($opt_info_style) {
  info();
  exit(0);
}


sub list_radio {
  listchans();
  if(%personal_stations) {
    print "\n\033[1mPersonal stations available:\033[0m\n";
    for my $shname(sort(keys(%personal_stations))) {
      printf("%-40s %s\n", %{$personal_stations{$shname}}->{name}, $shname);
    }
  }
}
sub fileexist {
  if(!-p $fifo) {
    require POSIX;
    POSIX::mkfifo($fifo, 0666) or croak("Cant mkfifo $fifo: $!");
  }
  if(-e $config) {
    require($config);
    print Dumper \%personal_stations if($DEBUG);
  }
}

sub load {
  my @toload = @_;
  if(defined(%{$channels->{$toload[0]}})) {
    $toload[0] = geturi($toload[0]);
  }
  if(defined($personal_stations{$toload[0]})) {
    $toload[0] = $personal_stations{$toload[0]}->{uri};
  }

  if(!-e $pidfile) { #not started
    if($toload[0] !~ m;(?:http|mms)://;) {
      my @fixme = @toload;
      for(@fixme) {
        s;.+/(.+);$1;;
        print "Adding \033[1m$1\033[0m\n";
      }
    }
    daemonize(); 
    exec($player, @playopt, @toload);
  }
  exit(0) if(!@toload);
  my @fixme = @toload;
  for(@fixme) { # FIXME
    s;.+/(.+);$1;;
    print "Adding \033[1m$1\033[0m\n";
  }
  open(my $fh, '>', $fifo) or croak("Cant open $fifo: $!");
  print $fh "loadfile @toload\n";
  exit(0);
}

sub cp {
  if(!$dir_to_copy_to) {
    print "Please specify destination dir in $config\n";
    exit(1);
  }
  my $file = np('file');
  if(!$file) {
    print "There's no file to copy!\n";
    exit(1);
  }
  if($file =~ m;(?:http|mms)://;) {
    print "You can not copy a stream\n";
    exit(1);
  }
  if(!-e $dir_to_copy_to) {
    if(mkdir($dir_to_copy_to)) {
      print "Created directory '$dir_to_copy_to'\n";
    }
    else {
      print "Could not create directory $dir_to_copy_to: $!\n";
      exit(1);
    }
  }
  if(copy($file, "$dir_to_copy_to/")) {
    print "'$file' -> '$dir_to_copy_to'\n";
    exit(0);
  }
  else {
    print "Copy failed: $!\n";
    exit(1);
  }
  exit 232;
}


sub cmd {
  # Tripplecheck that no other rmcd process are using the fifo!
  shift; # rid of getopt... 
  my $command = shift;
  my @args = @_;
  print "Command?\n" and exit(1) if(!$command);
  print Dumper "command: $command", "args: \@args\n" if($DEBUG);
  if(defined($allowed_cmds{$command})) {
    $command = $allowed_cmds{$command};
  }
  else {
    print "Arbitary command. You know what you are doing right?\n";
  }

  open(my $fh, '>', $fifo) or croak("Cant open $fifo: $!");
  print $fh "$command", @args, "\n";
  close($fh);
}

sub daemonize {
  use POSIX 'setsid';
  my $PID = fork();
  exit(0) if($PID); #parent
  exit(1) if(!defined($PID)); # out of resources

  setsid();
  $PID = fork();
  exit(1) if(!defined($PID));

  if($PID) { # parent
    waitpid($PID, 0);
    unlink($pidfile); # remove the lock when child have died
    exit(0);
  }
  elsif($PID == 0) { # child
    open(my $fh, '>', $pidfile) or die("Cant open $pidfile: $!");
    print $fh $$;
    close($fh);
    open(STDOUT, '>', $log);
    open(STDERR, '>', '/dev/null');
    open(STDIN,  '<', '/dev/null');
  }
}

sub killkid {
  open(my $fh, '<', $pidfile) or print "rmcd is not running\n" and exit(1);
  my $target = <$fh>;
  close($fh);

  if(kill(9, $target)) {
    print "Mplayerd with PID $target terminated\n";
  }
  else {
    print "Could not kill $target: $!";
  }
  exit(0);
}

sub info {
  my @c = undef;
  my($def,$bold,$italic) = ("\033[0m", "\033[1m", "\033[3m");

  if(`tput colors` > 255) {
    my $e = "\033[38;5";
    @c = (
      "$e;148m", "$e;250m", "$e;249m", "$e;248m", "$e;247m",
      "$e;246m", "$e;245m", "$e;244m", "$e;244m", "$e;243m",
      "$e;172m", "$e;178m",
    );
  }
  else {
    for(my $i=0;$i<9;$i++) {
      push(@c, "\033[3$i".'m');
    }
  }

  if(np('file') =~ m;(?:http|mms)://;) { # stream
    my $np = stream_np();

    my($title, $bitrate, $website, $genre) = ($np->{title}, $np->{bitrate},
    $np->{website}, $np->{genre});
    
    

    if($opt_info_style) {
      printf("%s from %s (%s)", $title, $website, $genre);
      exit(0);
    }

    printf("$bold$c[1]%7s$def: $bold$c[0]%.55s$def\n", 'Title', $title);
    printf("$bold$c[2]%7s$def: %.55s\n", 'Bitrate', $bitrate) unless !$bitrate;
    printf("$bold$c[3]%7s$def: %.55s\n", 'Genre', $genre);
    printf("$bold$c[4]%7s$def: %.55s\n", 'Channel', $website);
  }
  else {
    my $artist  = np('artist'); # solve this with sprintf() // 'foo'; 
    my $title   = np('title');
    my $album   = np('album');
    my $year    = np('year');
    my $comment = np('comment');
    my $bitrate = np('bitrate');
    my $genre   = np('genre');
    my $file    = np('file');

    $bitrate = $bitrate / 1000;

    if($opt_info_style) {

      printf("%s (%s) [%dkbps]", $file, $title, $bitrate);
      #printf("%s - %s (%s, %d)", $artist, $title, $genre, $year);
      exit(0);
    }

    printf("$bold$c[1]%7s$def: $bold$c[0]%.55s$def\n", 'Artist', $artist);
    printf("$bold$c[2]%7s$def: $c[11]%.55s$def\n", 'Album', $album);
    printf("$bold$c[3]%7s$def: $c[10]%.55s$def\n", 'Title', $title);
    printf("$bold$c[4]%7s$def: %.55s$def\n", 'Year',  $year);
    printf("$bold$c[5]%7s$def: %.55s$def\n", 'Comment', $comment);
    printf("$bold$c[6]%7s$def: %d kbps$def\n", 'Bitrate', $bitrate);
    printf("$bold$c[7]%7s$def: %.55s$def\n", 'Genre', $genre);
    printf("$bold$c[8]%7s$def: %.55s$def\n", 'File', $file);

  }
}

sub usage {
  print << "EOF";
  $APP $VERSION
  Usage: rmcd [OPTIONS] (FILES/URI)
  
  OPTIONS
    -l,   --load       play FILE(s)/URI or radio station (see -list)
    -ch,  --chanlist   list available radio channels
    -cm,  --cmd        send COMMAND to a running process (see shortcuts)
    -cl,  --clist      show a list of commands that are supported
    -cp,  --copy       copy TRACK to DESTDIR
    -i,   --info       show now playing information
    -si   --shinfo     show now playing information on single line
    -k,   --kill       kill the running process

  SHORTCUTS
    -n    --next       next in playlist
    -p    --prev       previous in playlist
    -t,   --toggle     toggle playback
    -s,   --stop       stop playback
    -f    --fullscreen toggle fullscreen


EOF
  exit(0);
}
