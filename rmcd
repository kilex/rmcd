#!/usr/bin/perl
=pod

=head1 NAME

  rmcd - Remotely control a daemonized Mplayer process

=head1 SYNOPSIS

  rmcd [OPTION]... [FILE/URI]

=head1 DESCRIPTION

B<rmcd> is a mplayer daemon/client - it daemonizes itself, playing
music/movies/radio stations and waiting for input through the named pipe.

You can send commands, load and play new content whenever you like.

You can run rmcd on one computer and remotely control it on another, fully
transparent. It only cares for the presence of the named pipe.

You can also setup mplayer to stream the content to you, creating a solution
similar to MPD and their builti-in httpd streaming (except MPD does not support
video streaming).

rmcd features a built-in, user configureable, webradio management system,
functionality for copying the current track to your portable mp3 player or
wherever you prefer, favorizing of tracks and loading of the same, now playing
information for both local files and streams, along other nifty stuff.

=head1 OPTIONS

    -l,   --load       play FILE(s)/URI or radio station (see -list)
    -ch,  --chanlist   list available radio channels
    -cm,  --cmd        send COMMAND to a running process (see shortcuts)
    -cl,  --clist      show a list of commands that are supported
    -cp,  --copy       copy TRACK to DESTDIR
    -i,   --info       show now playing information
    -si   --shinfo     show now playing information on single line
    -k,   --kill       kill the running process
    -h,   --help       show the help
    -m,   --man        show the manpage

=head2 Shortcuts for often used commands

    -n    --next       next in playlist
    -p    --prev       previous in playlist
    -t,   --toggle     toggle playback
    -s,   --stop       stop playback
    -f    --fullscreen toggle fullscreen

=head1 ENVIRONMENT

The configuration file should be placed in $XDG_CONFIG_HOME/rmcd/rmcd.conf

=head1 AUTHOR

Written by Magnus Woldrich.

=head1 REPORTING BUGS

Report bugs to trapd00r@trapd00r.se

rmcd home page: <http://github.com/trapd00r/rmcd/>

=head1 COPYRIGHT

Copyright 2010 Magnus Woldrich. License GPLv2: GNU GPL version 2 or later

This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

=head1 SEE ALSO

B<Radio Playing Daemon> <http://github.com/trapd00r/RPD/>

B<Mplayer::NowPlaying>  <http://github.com/trapd00r/Mplayer-NowPlaying/>

=cut

our $APP     = 'rmcd';
our $VERSION = 0.2;
my  $DEBUG   = 0;

use strict;
use Carp;
use Data::Dumper;
use Getopt::Long;
use Cwd qw(abs_path getcwd);
use File::Copy;
use Mplayer::NowPlaying qw($np_log np stream_np);
use RMCD::Radio qw(geturi listchans getchans);
use Pod::Usage;

usage() if(!@ARGV);

my $config         = "$ENV{XDG_CONFIG_HOME}/rmcd/rmcd.conf";
$config            = '/etc/rmcd.conf' unless(-e $config);
$config            = './rmcd.conf' if($DEBUG);
my $fifo           = "$ENV{HOME}/.mplayer/rmcd.fifo";
my $log            = "$ENV{HOME}/.mplayer/rmcd.log";
my $pidfile        = '/tmp/rmcd.pid';

my $player         = 'mplayer';
my @playopt        = ('-cache', 1400,
                      '-cache-min', 10,
                      '-identify',
                      '-idle',
                      '-input',
                      "file=$fifo"
                    );
$np_log = $log;

my $channels = getchans();

fileexist();

# imported from the config
our($dir_to_copy_to, %personal_stations, $custom_np);

my %allowed_cmds = (
  next    => 'pt_step 1',
  prev    => 'pt_step -1',
  toggle  => 'pause',
  pause   => 'pause',
  stop    => 'stop',
  fs      => 'fullscreen',
);

our($opt_info_style,@opt_play_songs) = (undef);
GetOptions(
  'kill'       => \&killkid,
  'load:s{1,}' => \@opt_play_songs,
  'cmd:s{,}'   => \&cmd,
  'help'       => \&usage,
  'man'        => sub {pod2usage(-verbose => 3)},
  'chanlist'   => \&list_radio,
  'info'       => \&info,
  'si|shinfo'  => sub {$opt_info_style = 1; info()},
  'cp|copy'    => \&cp,
  'fav'        => \&fav,
  'next'       => sub {cmd('FIXME','next')},
  'prev'       => sub {cmd('FIXME','prev')},
  'toggle'     => sub {cmd('FIXME','pause')},
  'fullscreen' => sub {cmd('FIXME','fs')},
  'stop'       => sub {cmd('FIXME','stop')},
  'clist'      => sub {
    print "$_\n" for(keys(%allowed_cmds));
    print "\033[1mSee 'mplayer -input cmdlist'\033[0m\n";
    exit(0);
  },
);

load(@opt_play_songs) if(@opt_play_songs);


if($opt_info_style) {
  info();
  exit(0);
}


sub list_radio {
  listchans();
  if(%personal_stations) {
    print "\n\033[1mPersonal stations available:\033[0m\n";
    for my $shname(sort(keys(%personal_stations))) {
      printf("%-40s %s\n", $personal_stations{$shname}{name}, $shname);
    }
  }
}
sub fileexist {
  if(!-p $fifo) {
    require POSIX;
    print $fifo, "\n\n";
    POSIX::mkfifo($fifo, 0666) or croak("Cant mkfifo $fifo: $!");
  }
  if(-e $config) {
    require($config);
    print Dumper \%personal_stations if($DEBUG);
  }
}

sub load {
  my @toload = @_;
  if((%{$channels->{$toload[0]}})) {
    # chan defined in RMCD::URI
    $toload[0] = geturi($toload[0]);
  }
  if(($personal_stations{$toload[0]})) {
    # chan defined in the configuration file
    $toload[0] = $personal_stations{$toload[0]}->{uri};
  }

  if(!-e $pidfile) { #not started
    if($toload[0] !~ m;(?:http|mms)://;) {
      my @fixme = @toload;
      for(@fixme) {
        s;.+/(.+);$1;;
        print "Adding \033[1m$1\033[0m\n";
      }
    }
    daemonize();
    exec($player, @playopt, @toload);
  }
  exit(0) if(!@toload);
  my @fixme = @toload;
  for(@fixme) { # FIXME
    s;.+/(.+);$1;;
    print "Adding \033[1m$1\033[0m\n";
  }
  open(my $fh, '>', $fifo) or croak("Cant open fifo $fifo: $!");
  print $fh "loadfile @toload\n";
  exit(0);
}

sub cp {
  if(!$dir_to_copy_to) {
    print "Please specify destination dir in $config\n";
    exit(1);
  }
  my $file = np('file');
  if(!$file) {
    print "There's no file to copy!\n";
    exit(1);
  }
  if($file =~ m;(?:http|mms)://;) {
    print "You can not copy a stream\n";
    exit(1);
  }
  if(!-e $dir_to_copy_to) {
    if(mkdir($dir_to_copy_to)) {
      print "Created directory '$dir_to_copy_to'\n";
    }
    else {
      print "Could not create directory $dir_to_copy_to: $!\n";
      exit(1);
    }
  }
  if(copy($file, "$dir_to_copy_to/")) {
    print "'$file' -> '$dir_to_copy_to'\n";
    exit(0);
  }
  else {
    print "Copy failed: $!\n";
    exit(1);
  }
  exit 232;
}


sub cmd {
  # Tripplecheck that no other rmcd process are using the fifo!
  shift; # rid of getopt...
  my $command = shift;
  my @args = @_;
  print "Command?\n" and exit(1) if(!$command);
  print Dumper "command: $command", "args: \@args\n" if($DEBUG);
  if(defined($allowed_cmds{$command})) {
    $command = $allowed_cmds{$command};
  }
  else {
    print "Arbitary command, trying anyway\n";
  }

  open(my $fh, '>', $fifo) or croak("Cant open $fifo: $!");
  print $fh "$command", @args, "\n";
  close($fh);
}

sub daemonize {
  use POSIX 'setsid';
  my $PID = fork();
  exit(0) if($PID); #parent
  exit(1) if(!defined($PID)); # out of resources

  setsid();
  $PID = fork();
  exit(1) if(!defined($PID));

  if($PID) { # parent
    waitpid($PID, 0);
    unlink($pidfile); # remove the lock when child have died
    exit(0);
  }
  elsif($PID == 0) { # child
    open(my $fh, '>', $pidfile) or die("Cant open $pidfile: $!");
    print $fh $$;
    close($fh);
    open(STDOUT, '>', $log);
    open(STDERR, '>', '/dev/null');
    open(STDIN,  '<', '/dev/null');
  }
}

sub killkid {
  open(my $fh, '<', $pidfile) or print "rmcd is not running\n" and exit(1);
  my $target = <$fh>;
  close($fh);

  if(kill(9, $target)) {
    print "rmcd with PID $target terminated\n";
  }
  else {
    print "Could not kill $target: $!";
  }
  exit(0);
}

sub info {
  my @c = undef;
  my($def,$bold,$italic) = ("\033[0m", "\033[1m", "\033[3m");

  if(`tput colors` > 255) {
    my $e = "\033[38;5";
    @c = (
      "$e;148m", "$e;250m", "$e;249m", "$e;248m", "$e;247m",
      "$e;246m", "$e;245m", "$e;244m", "$e;244m", "$e;243m",
      "$e;172m", "$e;178m",
    );
  }
  else {
    for(my $i=0;$i<9;$i++) {
      push(@c, "\033[3$i".'m');
    }
  }

  if(np('file') =~ m;http://192;) {
    # local stream
    if(defined($custom_np)) {
      if(ref($custom_np)) { #coderef

        if($opt_info_style) { # short info
          $custom_np->('sometimes you gotta say shut up');
          exit(0);
        }
        $custom_np->() or return(1);
      }
      else {
        print $custom_np;
      }
    }
  }

  if(np('file') =~ m;(?:http|mms)://;) { # remote stream
    my $np = stream_np();

    my($title, $bitrate, $website, $genre) = ($np->{title}, $np->{bitrate},
    $np->{website}, $np->{genre});


    if($website eq 'Add config information here!') {
      # mpd httpd stream
      $website = undef;
    }
    if($genre eq 'Add config information here!') {
      $genre = undef;
    }

    if($opt_info_style) { # oneliner info
      printf("%s from %s (%s)", $title, $website, $genre);
      exit(0);
    }

    printf("%7s: $c[9]$bold%s$def\n", 'Title', $title) unless(!$title);
    printf("%7s: %s\n", 'Genre', $genre) unless(!$genre);
    printf("%7s: %s\n", 'Bitrate', $bitrate) unless(!$bitrate);
    printf("%7s: %s\n", 'Channel', $website) unless(!$website);
  }
  else {
    my $artist  = np('artist'); # solve this with sprintf() // 'foo'; 
    my $title   = np('title');
    my $album   = np('album');
    my $year    = np('year');
    my $comment = np('comment');
    my $bitrate = np('bitrate');
    my $genre   = np('genre');
    my $file    = np('file');

    $bitrate = $bitrate / 1000;


    if($opt_info_style) {

      printf("%s (%s) [%dkbps]", $file, $title, $bitrate);
      #printf("%s - %s (%s, %d)", $artist, $title, $genre, $year);
      exit(0);
    }

    printf("$bold$c[1]%7s$def: $bold$c[0]%s$def\n", 'Artist', $artist);
    printf("$bold$c[2]%7s$def: $c[11]%s$def\n", 'Album', $album);
    printf("$bold$c[3]%7s$def: $c[10]%s$def\n", 'Title', $title);
    printf("$bold$c[4]%7s$def: %.55s$def\n", 'Year',  $year);
    printf("$bold$c[5]%7s$def: %.55s$def\n", 'Comment', $comment);
    printf("$bold$c[6]%7s$def: %d kbps$def\n", 'Bitrate', $bitrate);
    printf("$bold$c[7]%7s$def: %.55s$def\n", 'Genre', $genre);
    printf("$bold$c[8]%7s$def: %.55s$def\n", 'File', $file);

  }
}

sub usage {
  pod2usage(-verbose => 1);
  exit(0);
}
