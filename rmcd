#!/usr/bin/perl
=pod

=head1 NAME

  rmcd - Remotely control a daemonized Mplayer process

=head1 SYNOPSIS

  rmcd [OPTION]... [FILE/URI]

=head1 DESCRIPTION

B<rmcd> is a mplayer daemon/client - it daemonizes itself, playing
music/movies/radio stations and waiting for input through the named pipe.

You can send commands, load and play new content whenever you like.

You can run rmcd on one computer and remotely control it on another, fully
transparent. It only cares for the presence of the named pipe.

You can also setup mplayer to stream the content to you, creating a solution
similar to MPD and their builti-in httpd streaming (except MPD does not support
video streaming).

rmcd features a built-in, user configureable, webradio management system,
functionality for copying the current track to your portable mp3 player or
wherever you prefer, favorizing of tracks and loading of the same, now playing
information for both local files and streams, along with other nifty stuff.

=head1 OPTIONS

    -l,   --load       play FILE(s)/URI or radio station (see -chanlist)
    -r,   --shuffle    shuffle the playlist before adding it
          --playlist   show the current playlist
          --chanlist   list available radio channels
          --cmd        send COMMAND to a running process (see shortcuts)
          --clist      show a list of commands that are supported
    -cp,  --copy       copy TRACK to DESTDIR
    -ccp, --custom-cp  execute a custom copy function, as specified in rmcd.conf
    -i,   --info       show now playing information
    -si   --shinfo     show now playing information on single line
    -k,   --kill       kill the running process
    -h,   --help       show the help
    -m,   --man        show the manpage

=head2 Shortcuts for often used commands

    -n,   --next       next in playlist
    -p,   --prev       previous in playlist
    -t,   --toggle     toggle playback
    -s,   --stop       stop playback
    -f,   --fullscreen toggle fullscreen

=head1 ENVIRONMENT

The configuration file should be placed in $XDG_CONFIG_HOME/rmcd/rmcd.conf

=head1 AUTHOR

Written by Magnus Woldrich.

=head1 REPORTING BUGS

Report bugs to trapd00r@trapd00r.se

rmcd home page: <http://github.com/trapd00r/rmcd/>

=head1 COPYRIGHT

Copyright 2010 Magnus Woldrich. License GPLv2: GNU GPL version 2 or later

This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

=head1 SEE ALSO

rmcd.conf(1)

B<Radio Playing Daemon> <http://github.com/trapd00r/RPD/>

B<Mplayer::NowPlaying>  <http://github.com/trapd00r/Mplayer-NowPlaying/>

=cut

our $APP     = 'rmcd';
our $VERSION = '0.2.3';
my  $DEBUG   = 0;

use strict;
use Carp;
use Data::Dumper;
use Getopt::Long;
use Cwd qw(abs_path getcwd);
use File::Copy;
use Mplayer::NowPlaying qw($np_log np stream_np);
use Pod::Usage;
use List::Util 'shuffle';

usage() if(!@ARGV);

my $config         = "$ENV{XDG_CONFIG_HOME}/rmcd/rmcd.conf";
$config            = '/etc/rmcd.conf' unless(-e $config);
$config            = './rmcd.conf' if($DEBUG);
my $fifo           = "$ENV{HOME}/.mplayer/rmcd.fifo";
my $log            = "$ENV{HOME}/.mplayer/rmcd.log";
my $pidfile        = '/tmp/rmcd.pid';

my $player         = 'mplayer';
my @playopt        = ('-cache', 1400,
                      '-cache-min', 10,
                      '-identify',
                      '-idle',
                      '-input',
                      "file=$fifo"
                    );
$np_log = $log;
my $temp_playlist  = '/tmp/rmcd-playlist';

fileexist();

# imported from the config
our($dir_to_copy_to, %channels, $custom_np, $custom_cp);

my %allowed_cmds = (
  next    => 'pt_step 1',
  prev    => 'pt_step -1',
  toggle  => 'pause',
  pause   => 'pause',
  stop    => 'stop',
  fs      => 'fullscreen',
);

our($opt_info_style,@opt_play_songs) = (undef);
our($opt_shuffle) = 0;
GetOptions(
  'kill'          => \&killkid,
  'load:s{1,}'    => \@opt_play_songs,
  'cmd:s{,}'      => \&cmd,
  'help'          => \&usage,
  'man'           => sub {pod2usage(-verbose => 3)},
  'chanlist'      => \&list_channels,
  'info'          => \&info,
  'si|shinfo'     => sub {$opt_info_style = 1; info()},
  'cp|copy'       => \&cp,
  'playlist'      => \&show_playlist,
  'ccp|custom-cp' => \&custom_cp_legal,
  'fav'           => \&fav,
  'r|shuffle'     => \$opt_shuffle,
  'next'          => sub {cmd(undef,'next')},
  'p|prev'        => sub {cmd(undef,'prev')},
  'toggle'        => sub {cmd(undef,'pause')},
  'fullscreen'    => sub {cmd(undef,'fs')},
  'stop'          => sub {cmd(undef,'stop')},
  'clist'         => sub {
    print "$_\n" for(keys(%allowed_cmds));
    print "\033[1mSee 'mplayer -input cmdlist'\033[0m\n";
    exit(0);
  },
);

if($opt_shuffle and !@opt_play_songs) {
  print STDERR "You can not shuffle nothingness\n" and exit(-1);
}

if(@opt_play_songs) {
  if($opt_shuffle) {
    @opt_play_songs = shuffle(@opt_play_songs);
  }
  load(@opt_play_songs);
}

if($opt_info_style) {
  info();
  exit(0);
}

sub show_playlist {
  my $current_file = np('file');
  return(-1) if(!$current_file);

  open(my $fh, '<', $temp_playlist) or die("Can not open $temp_playlist: $!");
  chomp(my @list = <$fh>);
  close($fh);

  # stream FIXME arbitary streams
  if($channels{$list[0]}) {
    printf("%s (%s)\n", $channels{$list[0]}{name}, $channels{$list[0]}{uri});
    exit(0);
  }


  for(@list) {
    if($_ eq $current_file) {
      $_ =~ m;.+/(.+)$;;
      printf("\033[1m\033[34m%s\033[0m\n", ($1) ? $1 : $_);
    }
    else {
      $_ =~ m;.+/(.+)$;;
      printf("%s\n", ($1) ? $1 : $_);
    }
  }
  printf("\n%s: \033[1m%s\033[0m\n", 'Random',
    ($opt_shuffle) ? 'Off' : 'On'
  );
  exit(0);
}

sub custom_cp_legal {
  if(ref($custom_cp) eq 'CODE') {
    $custom_cp->(); # bye. everything from now on is the users fault :)
  }
  else {
    print "\033[1m$custom_cp\e[0m is not a code reference\n";
    exit(-1);
  }
}

sub geturi {
  my $chname = shift;
  return(undef) unless(exists($channels{$chname}));
  return $channels{$chname}->{uri};
}

sub list_channels {
  for my $chname(sort(keys(%channels))) {
    printf("%40s \033[1m%s\033[0m\n", $channels{$chname}{name}, $chname);
  }
}

sub getchname {
  my $chname = shift;
  return($channels{$chname}{name});
}

sub fileexist {
  if(!-p $fifo) {
    require POSIX;
    print $fifo, "\n\n";
    POSIX::mkfifo($fifo, 0666) or croak("Cant mkfifo $fifo: $!");
  }
  if(-e $config) {
    require($config);
    print Dumper \%channels if($DEBUG);
  }
}

sub load {
  my @toload = @_;
  #FIXME
  my $listing = join("\n", @toload);
  if(($channels{$toload[0]})) {
    # chan defined in the configuration file
    $toload[0] = $channels{$toload[0]}->{uri};
  }

  if(!-e $pidfile) { #not started
    if($toload[0] !~ m;(?:http|mms)://;) {
      my @fixme = @toload;
      for(@fixme) {
        s;.+/(.+);$1;;
        print "Adding \033[1m$1\033[0m\n";
      }
    }
    # regular files

    open(my $plist, '>', $temp_playlist)
      or die("Can not open $temp_playlist: $!");
    print $plist $listing;
    close($plist);
    daemonize();
    exec($player, @playopt, @toload);
  }

  # rmcd was already running

  exit(0) if(!@toload);
  my @fixme = @toload;
  for(@fixme) { # FIXME
    s;.+/(.+);$1;;
    print "Adding \033[1m$1\033[0m\n";
  }
  open(my $fh, '>', $fifo) or die("Can not open $fifo: $!"); 
  print $fh "load @toload\n";
  close($fh);

  open(my $plist, '>', $temp_playlist)
    or die("Can not open $temp_playlist: $!");

  print $plist $listing;
  close($plist);


  exit(0);
}

sub cp {
  if(!$dir_to_copy_to) {
    print "Please specify destination dir in $config\n";
    exit(1);
  }
  my $file = np('file');
  if(!$file) {
    print "There's no file to copy!\n";
    exit(1);
  }
  if($file =~ m;(?:http|mms)://;) {
    print "You can not copy a stream\n";
    exit(1);
  }
  if(!-e $dir_to_copy_to) {
    if(mkdir($dir_to_copy_to)) {
      print "Created directory '$dir_to_copy_to'\n";
    }
    else {
      print "Could not create directory $dir_to_copy_to: $!\n";
      exit(1);
    }
  }
  if(copy($file, "$dir_to_copy_to/")) {
    print "'$file' -> '$dir_to_copy_to'\n";
    exit(0);
  }
  else {
    print "Copy failed: $!\n";
    exit(1);
  }
  exit(0);
}


sub cmd {
  # Tripplecheck that no other rmcd process are using the fifo!
  shift; # rid of getopt...
  my $command = shift;
  my @args = @_;
  print "Command?\n" and exit(1) if(!$command);
  print Dumper "command: $command", "args: \@args\n" if($DEBUG);
  if(defined($allowed_cmds{$command})) {
    $command = $allowed_cmds{$command};
  }
  else {
    print "Arbitary command, trying anyway\n";
  }

  open(my $fh, '>', $fifo) or croak("Cant open $fifo: $!");
  print $fh "$command", @args, "\n";
  close($fh);
}

sub daemonize {
  use POSIX 'setsid';
  my $PID = fork();
  exit(0) if($PID); #parent
  exit(1) if(!defined($PID)); # out of resources

  setsid();
  $PID = fork();
  exit(1) if(!defined($PID));

  if($PID) { # parent
    waitpid($PID, 0);
    unlink($pidfile); # remove the lock when child have died

    #TODO Use this for starting playback where one left off..
    unlink($temp_playlist);
    unlink("/tmp/rmcd-playlist.$$");
    exit(0);
  }
  elsif($PID == 0) { # child
    open(my $fh, '>', $pidfile) or die("Cant open $pidfile: $!");
    print $fh $$;
    close($fh);
    open(STDOUT, '>', $log);
    open(STDERR, '>', '/dev/null');
    open(STDIN,  '<', '/dev/null');
  }
}

sub killkid {
  open(my $fh, '<', $pidfile) or print "rmcd is not running\n" and exit(1);
  my $target = <$fh>;
  close($fh);

  if(kill(9, $target)) {
    print "rmcd with PID $target terminated\n";
  }
  else {
    print "Could not kill $target: $!";
  }
  exit(0);
}

sub info {
  my @c = undef;
  my($def,$bold,$italic) = ("\033[0m", "\033[1m", "\033[3m");

  if(`tput colors` > 255) {
    my $e = "\033[38;5";
    @c = (
      "$e;148m", "$e;250m", "$e;249m", "$e;248m", "$e;247m",
      "$e;246m", "$e;245m", "$e;244m", "$e;244m", "$e;243m",
      "$e;172m", "$e;178m",
    );
  }
  else {
    for(my $i=0;$i<9;$i++) {
      push(@c, "\033[3$i".'m');
    }
  }

  if(np('file') =~ m;http://192;) {
    # local stream
    if(defined($custom_np)) {
      if(ref($custom_np)) { #coderef

        if($opt_info_style) { # short info
          $custom_np->('sometimes you gotta say shut up');
          exit(0);
        }
        $custom_np->() or return(1);
      }
      else {
        print $custom_np;
      }
    }
  }

  if(np('file') =~ m;(?:http|mms)://;) { # remote stream
    my $np = stream_np();

    my($title, $bitrate, $website, $genre) = ($np->{title}, $np->{bitrate},
    $np->{website}, $np->{genre});


    if($website eq 'Add config information here!') {
      # mpd httpd stream
      $website = undef;
    }
    if($genre eq 'Add config information here!') {
      $genre = undef;
    }

    if($opt_info_style) { # oneliner info
      printf("%s from %s (%s)", $title, $website, $genre);
      exit(0);
    }

    printf("%7s: $c[9]$bold%s$def\n", 'Title', $title) unless(!$title);
    printf("%7s: %s\n", 'Genre', $genre) unless(!$genre);
    printf("%7s: %s\n", 'Bitrate', $bitrate) unless(!$bitrate);
    printf("%7s: %s\n", 'Channel', $website) unless(!$website);
  }
  else {
    my $artist  = np('artist'); # solve this with sprintf() // 'foo'; 
    my $title   = np('title');
    my $album   = np('album');
    my $year    = np('year');
    my $comment = np('comment');
    my $bitrate = np('bitrate');
    my $genre   = np('genre');
    my $file    = np('file');

    $bitrate = $bitrate / 1000;


    if($opt_info_style) {

      printf("%s (%s) [%dkbps]", $file, $title, $bitrate);
      #printf("%s - %s (%s, %d)", $artist, $title, $genre, $year);
      exit(0);
    }

    printf("$bold$c[1]%7s$def: $bold$c[0]%s$def\n", 'Artist', $artist);
    printf("$bold$c[2]%7s$def: $c[11]%s$def\n", 'Album', $album);
    printf("$bold$c[3]%7s$def: $c[10]%s$def\n", 'Title', $title);
    printf("$bold$c[4]%7s$def: %.55s$def\n", 'Year',  $year);
    printf("$bold$c[5]%7s$def: %.55s$def\n", 'Comment', $comment);
    printf("$bold$c[6]%7s$def: %d kbps$def\n", 'Bitrate', $bitrate);
    printf("$bold$c[7]%7s$def: %.55s$def\n", 'Genre', $genre);
    printf("$bold$c[8]%7s$def: %.55s$def\n", 'File', $file);

  }
}

sub usage {
  print "$APP $VERSION\n";
  pod2usage(-verbose => 1);
  exit(0);
}
